package machine

import (
	"github.com/golang/mock/gomock"
	kubevirtproviderv1 "github.com/kubevirt/cluster-api-provider-kubevirt/pkg/apis/kubevirtprovider/v1"
	kubevirtClient "github.com/kubevirt/cluster-api-provider-kubevirt/pkg/client"
	mockkubevirtclient "github.com/kubevirt/cluster-api-provider-kubevirt/pkg/client/mock"
	machineapiapierrors "github.com/kubevirt/cluster-api-provider-kubevirt/vendor/github.com/openshift/machine-api-operator/pkg/controller/machine"
	apimachineryerrors "github.com/kubevirt/cluster-api-provider-kubevirt/vendor/k8s.io/apimachinery/pkg/api/errors"
	metav1 "github.com/kubevirt/cluster-api-provider-kubevirt/vendor/k8s.io/apimachinery/pkg/apis/meta/v1"
	kubernetesclient "github.com/kubevirt/cluster-api-provider-kubevirt/vendor/k8s.io/client-go/kubernetes"
	"gotest.tools/assert"
	v1 "kubevirt.io/client-go/api/v1"
	"kubevirt.io/client-go/kubecli"
	cdiv1 "kubevirt.io/containerized-data-importer/pkg/apis/core/v1alpha1"
	"testing"
)

// func init() {
// 	// Add types to scheme
// 	machinev1.AddToScheme(scheme.Scheme)
// }

// type placementMatcher struct {
// 	placement *ec2.Placement
// }

// func (m placementMatcher) Matches(input interface{}) bool {
// 	runInstancesInput, ok := input.(*ec2.RunInstancesInput)
// 	if !ok {
// 		return false
// 	}
// 	if runInstancesInput.Placement == m.placement {
// 		return true
// 	}
// 	return false
// }

// func (m placementMatcher) String() string {
// 	return fmt.Sprintf("is placement: %#v", m.placement)
// }

func newMachineScopeMock() {

}
func TestCreate(t *testing.T) {

	cases := []struct {
		name              string
		wantErr           error
		//virtualMachineCreateErr        error
		createMachineParams string
	}{
		{
			name: "Create a VM",
			wantErr:        nil,
			createMachineParams: nil,
		},
	}
	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			mockCtrl := gomock.NewController(t)
			// Assert that Bar() is invoked.
			defer mockCtrl.Finish()
			mockKubevirtClient := mockkubevirtclient.NewMockClient(mockCtrl)

			// TODO: use createMachineParams if needed
			machine, stubMachineErr := stubMachine()

			if stubMachineErr != nil {
				t.Fatalf("Unable to build test machine manifest: %v", stubMachineErr)
			}

			machineScope, newMachineScopeErr := newMachineScope(machineScopeParams{
				kubevirtClientBuilder:  func(kubernetesClient *kubernetesclient.Clientset, secretName, namespace string) (kubevirtClient.Client, error) {
					return mockKubevirtClient, nil
				},
				machine: machine,
				kubernetesClient: nil,
				Context: nil,
			})

			if newMachineScopeErr != nil {
				t.Fatal(newMachineScopeErr)
			}

			mockKubevirtClient.EXPECT().CreateVirtualMachine(defaultNamespace, machineScope.virtualMachine).Return(machineScope.virtualMachine, nil).AnyTimes()

			createVMErr := providerVM{machineScope}.create()

			if tc.wantErr != nil {
				assert.Equal(t, tc.wantErr, createVMErr)
			} else {
				assert.Equal(t, createVMErr, nil)
			}
		})
	}

	createVMObj := func() {

		vm, _ := DefaultVirtualMachine(true)

		//vm.Spec.Template.Spec.Volumes = append(vm.Spec.Template.Spec.Volumes, v1.Volume{
		//	Name: "test1",
		//	VolumeSource: v1.VolumeSource{
		//		DataVolume: &v1.DataVolumeSource{
		//			Name: "dv1",
		//		},
		//	},
		//})

		//vm.Spec.DataVolumeTemplates = append(vm.Spec.DataVolumeTemplates, cdiv1.DataVolume{
		//	ObjectMeta: metav1.ObjectMeta{
		//		Labels:      map[string]string{"my": "label"},
		//		Annotations: map[string]string{"my": "annotation"},
		//		Name:        "dv1",
		//	},
		//})
		//vm.Spec.DataVolumeTemplates = append(vm.Spec.DataVolumeTemplates, cdiv1.DataVolume{
		//	ObjectMeta: metav1.ObjectMeta{
		//		Name: "dv2",
		//	},
		//})
		//addVirtualMachine(vm)

		//existingDataVolume := createDataVolumeManifest(&vm.Spec.DataVolumeTemplates[1], vm)
		//existingDataVolume.Namespace = "default"
		//dataVolumeFeeder.Add(existingDataVolume)
		//createCount := 0
		//shouldExpectDataVolumeCreation(vm.UID, map[string]string{"kubevirt.io/created-by": "", "my": "label"}, map[string]string{"my": "annotation"}, &createCount)
		//controller.Execute()
		//Expect(createCount).To(Equal(1))
		//testutils.ExpectEvent(recorder, SuccessfulDataVolumeCreateReason)
	}

	createVMObj()

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			mockCtrl := gomock.NewController(t)
			// Assert that Bar() is invoked.
			defer mockCtrl.Finish()
			mockKubevirtClient := mockkubevirtclient.NewMockClient(mockCtrl)

			mockKubevirtClient.EXPECT().CreateVirtualMachine(gomock.Any(),gomock.Any()).Return(nil, nil).AnyTimes()
			//mockKubevirtClient.EXPECT().UpdateVirtualMachine(gomock.Any()).Return(tc.securityGroupOutput, tc.securityGroupErr).AnyTimes()
			//mockKubevirtClient.EXPECT().DeleteVirtualMachine(gomock.Any()).Return(tc.subnetOutput, tc.subnetErr).AnyTimes()
			//mockKubevirtClient.EXPECT().ListVirtualMachine(gomock.Any()).Return(tc.imageOutput, tc.imageErr).AnyTimes()
			//mockKubevirtClient.EXPECT().GetVirtualMachine(gomock.Any()).Return(tc.imageOutput, tc.imageErr).AnyTimes()
			//mockKubevirtClient.EXPECT().PatchVirtualMachine(gomock.Any()).Return(tc.imageOutput, tc.imageErr).AnyTimes()
			//mockKubevirtClient.EXPECT().RestartVirtualMachine(gomock.Any()).Return(tc.instancesOutput, tc.instancesErr).AnyTimes()
			//mockKubevirtClient.EXPECT().StartVirtualMachine(gomock.Any()).Return(tc.instancesOutput, tc.instancesErr).AnyTimes()
			//mockKubevirtClient.EXPECT().StopVirtualMachine(gomock.Any()).Return(tc.instancesOutput, tc.instancesErr).AnyTimes()

			vmMap := map[string]*v1.VirtualMachine{
				"nodeHostname":   v1.NewMinimalVMIWithNS(namespace, "nodehostname"),
				"nodeNoHostname": v1.NewMinimalVMIWithNS(namespace, "nodenohostname"),
			}

			_, launchErr := launchInstance(machine, tc.providerConfig, nil, mockKubevirtClient)
			t.Log(launchErr)
			if launchErr == nil {
				if !tc.succeeds {
					t.Errorf("Call to launchInstance did not fail as expected")
				}
			} else {
				if tc.succeeds {
					t.Errorf("Call to launchInstance did not succeed as expected")
				}
			}
			// TODO: kubevirtClientBuilder???
			// TODO: kubernetesClient???
			machineScope, newMachineScopeErr := newMachineScope(machineScopeParams{
				kubevirtClientBuilder:  nil,
				machine: machine,
				kubernetesClient: nil,
				Context: nil,
				})

			if newMachineScopeErr != nil {
				t.Fatal(err)
			}

			providerVM := newProviderVM(machineScope)
			vm, createVMErr:= providerVM.create()
			if tc.succeeds {
				/**
				got := p.Get(context.Background(), params)
				if tt.wantErr == nil {
					assert.Equal(t, want, got)
				} else {
					assert.Equal(t, tt.wantErr, got)
				}
				*/
				//ccc
			}

		})
	}
}
func DefaultVirtualMachine(started bool) (*v1.VirtualMachine, *v1.VirtualMachineInstance) {
	return DefaultVirtualMachineWithNames(started, "testvmi", "testvmi")
}

func DefaultVirtualMachineWithNames(started bool, vmName string, vmiName string) (*v1.VirtualMachine, *v1.VirtualMachineInstance) {
	vmi := v1.NewMinimalVMI(vmiName)
	vmi.Status.Phase = v1.Running
	vm := VirtualMachineFromVMI(vmName, vmi, started)
	t := true
	vmi.OwnerReferences = []metav1.OwnerReference{{
		APIVersion:         v1.VirtualMachineGroupVersionKind.GroupVersion().String(),
		Kind:               v1.VirtualMachineGroupVersionKind.Kind,
		Name:               vm.ObjectMeta.Name,
		UID:                vm.ObjectMeta.UID,
		Controller:         &t,
		BlockOwnerDeletion: &t,
	}}
	return vm, vmi
}

func VirtualMachineFromVMI(name string, vmi *v1.VirtualMachineInstance, started bool) *v1.VirtualMachine {
	vm := &v1.VirtualMachine{
		ObjectMeta: metav1.ObjectMeta{Name: name, Namespace: vmi.ObjectMeta.Namespace, ResourceVersion: "1"},
		Spec: v1.VirtualMachineSpec{
			Running: &started,
			Template: &v1.VirtualMachineInstanceTemplateSpec{
				ObjectMeta: metav1.ObjectMeta{
					Name:   vmi.ObjectMeta.Name,
					Labels: vmi.ObjectMeta.Labels,
				},
				Spec: vmi.Spec,
			},
		},
	}
	return vm
}
	// // mock aws API calls
	// mockCtrl := gomock.NewController(t)
	// mockAWSClient := mockaws.NewMockClient(mockCtrl)
	// mockAWSClient.EXPECT().DescribeSecurityGroups(gomock.Any()).Return(nil, fmt.Errorf("describeSecurityGroups error")).AnyTimes()
	// mockAWSClient.EXPECT().DescribeAvailabilityZones(gomock.Any()).Return(nil, fmt.Errorf("describeAvailabilityZones error")).AnyTimes()
	// mockAWSClient.EXPECT().DescribeImages(gomock.Any()).Return(nil, fmt.Errorf("describeImages error")).AnyTimes()
	// mockAWSClient.EXPECT().DescribeInstances(gomock.Any()).Return(stubDescribeInstancesOutput("ami-a9acbbd6", "i-02fcb933c5da7085c", ec2.InstanceStateNameRunning), nil).AnyTimes()
	// mockAWSClient.EXPECT().TerminateInstances(gomock.Any()).Return(&ec2.TerminateInstancesOutput{}, nil).AnyTimes()
	// mockAWSClient.EXPECT().RunInstances(gomock.Any()).Return(stubReservation("ami-a9acbbd6", "i-02fcb933c5da7085c"), nil).AnyTimes()
	// mockAWSClient.EXPECT().RegisterInstancesWithLoadBalancer(gomock.Any()).Return(nil, nil).AnyTimes()
	// mockAWSClient.EXPECT().ELBv2DescribeLoadBalancers(gomock.Any()).Return(stubDescribeLoadBalancersOutput(), nil)
	// mockAWSClient.EXPECT().ELBv2DescribeTargetGroups(gomock.Any()).Return(stubDescribeTargetGroupsOutput(), nil).AnyTimes()
	// mockAWSClient.EXPECT().ELBv2RegisterTargets(gomock.Any()).Return(nil, nil).AnyTimes()

	// testCases := []struct {
	// 	testcase             string
	// 	providerConfig       *awsproviderv1.AWSMachineProviderConfig
	// 	userDataSecret       *corev1.Secret
	// 	awsCredentialsSecret *corev1.Secret
	// 	expectedError        error
	// }{
	// 	{
	// 		testcase: "Create succeed",
	// 		providerConfig: &awsproviderv1.AWSMachineProviderConfig{
	// 			AMI: awsproviderv1.AWSResourceReference{
	// 				ID: aws.String("ami-a9acbbd6"),
	// 			},
	// 			CredentialsSecret: &corev1.LocalObjectReference{
	// 				Name: awsCredentialsSecretName,
	// 			},
	// 			InstanceType: "m4.xlarge",
	// 			Placement: awsproviderv1.Placement{
	// 				Region:           region,
	// 				AvailabilityZone: defaultAvailabilityZone,
	// 			},
	// 			Subnet: awsproviderv1.AWSResourceReference{
	// 				ID: aws.String("subnet-0e56b13a64ff8a941"),
	// 			},
	// 			IAMInstanceProfile: &awsproviderv1.AWSResourceReference{
	// 				ID: aws.String("openshift_master_launch_instances"),
	// 			},
	// 			KeyName: aws.String(keyName),
	// 			UserDataSecret: &corev1.LocalObjectReference{
	// 				Name: userDataSecretName,
	// 			},
	// 			Tags: []awsproviderv1.TagSpecification{
	// 				{Name: "openshift-node-group-config", Value: "node-config-master"},
	// 				{Name: "host-type", Value: "master"},
	// 				{Name: "sub-host-type", Value: "default"},
	// 			},
	// 			SecurityGroups: []awsproviderv1.AWSResourceReference{
	// 				{ID: aws.String("sg-00868b02fbe29de17")},
	// 				{ID: aws.String("sg-0a4658991dc5eb40a")},
	// 				{ID: aws.String("sg-009a70e28fa4ba84e")},
	// 				{ID: aws.String("sg-07323d56fb932c84c")},
	// 				{ID: aws.String("sg-08b1ffd32874d59a2")},
	// 			},
	// 			PublicIP: aws.Bool(true),
	// 			LoadBalancers: []awsproviderv1.LoadBalancerReference{
	// 				{
	// 					Name: "cluster-con",
	// 					Type: awsproviderv1.ClassicLoadBalancerType,
	// 				},
	// 				{
	// 					Name: "cluster-ext",
	// 					Type: awsproviderv1.ClassicLoadBalancerType,
	// 				},
	// 				{
	// 					Name: "cluster-int",
	// 					Type: awsproviderv1.ClassicLoadBalancerType,
	// 				},
	// 				{
	// 					Name: "cluster-net-lb",
	// 					Type: awsproviderv1.NetworkLoadBalancerType,
	// 				},
	// 			},
	// 		},
	// 		userDataSecret:       stubUserDataSecret(),
	// 		awsCredentialsSecret: stubAwsCredentialsSecret(),
	// 		expectedError:        nil,
	// 	},
	// 	{
	// 		testcase: "Bad userData",
	// 		providerConfig: &awsproviderv1.AWSMachineProviderConfig{
	// 			AMI: awsproviderv1.AWSResourceReference{
	// 				ID: aws.String("ami-a9acbbd6"),
	// 			},
	// 			CredentialsSecret: &corev1.LocalObjectReference{
	// 				Name: awsCredentialsSecretName,
	// 			},
	// 			InstanceType: "m4.xlarge",
	// 			Placement: awsproviderv1.Placement{
	// 				Region:           region,
	// 				AvailabilityZone: defaultAvailabilityZone,
	// 			},
	// 			Subnet: awsproviderv1.AWSResourceReference{
	// 				ID: aws.String("subnet-0e56b13a64ff8a941"),
	// 			},
	// 			IAMInstanceProfile: &awsproviderv1.AWSResourceReference{
	// 				ID: aws.String("openshift_master_launch_instances"),
	// 			},
	// 			KeyName: aws.String(keyName),
	// 			UserDataSecret: &corev1.LocalObjectReference{
	// 				Name: userDataSecretName,
	// 			},
	// 			Tags: []awsproviderv1.TagSpecification{
	// 				{Name: "openshift-node-group-config", Value: "node-config-master"},
	// 				{Name: "host-type", Value: "master"},
	// 				{Name: "sub-host-type", Value: "default"},
	// 			},
	// 			SecurityGroups: []awsproviderv1.AWSResourceReference{
	// 				{ID: aws.String("sg-00868b02fbe29de17")},
	// 				{ID: aws.String("sg-0a4658991dc5eb40a")},
	// 				{ID: aws.String("sg-009a70e28fa4ba84e")},
	// 				{ID: aws.String("sg-07323d56fb932c84c")},
	// 				{ID: aws.String("sg-08b1ffd32874d59a2")},
	// 			},
	// 			PublicIP: aws.Bool(true),
	// 			LoadBalancers: []awsproviderv1.LoadBalancerReference{
	// 				{
	// 					Name: "cluster-con",
	// 					Type: awsproviderv1.ClassicLoadBalancerType,
	// 				},
	// 				{
	// 					Name: "cluster-ext",
	// 					Type: awsproviderv1.ClassicLoadBalancerType,
	// 				},
	// 				{
	// 					Name: "cluster-int",
	// 					Type: awsproviderv1.ClassicLoadBalancerType,
	// 				},
	// 				{
	// 					Name: "cluster-net-lb",
	// 					Type: awsproviderv1.NetworkLoadBalancerType,
	// 				},
	// 			},
	// 		},
	// 		userDataSecret: &corev1.Secret{
	// 			ObjectMeta: metav1.ObjectMeta{
	// 				Name:      userDataSecretName,
	// 				Namespace: defaultNamespace,
	// 			},
	// 			Data: map[string][]byte{
	// 				"badKey": []byte(userDataBlob),
	// 			},
	// 		},
	// 		awsCredentialsSecret: stubAwsCredentialsSecret(),
	// 		expectedError:        errors.New("failed to get user data: secret default/aws-actuator-user-data-secret missing userData key"),
	// 	},
	// 	{
	// 		testcase: "Failed security groups return invalid config machine error",
	// 		providerConfig: &awsproviderv1.AWSMachineProviderConfig{
	// 			AMI: awsproviderv1.AWSResourceReference{
	// 				ID: aws.String("ami-a9acbbd6"),
	// 			},
	// 			CredentialsSecret: &corev1.LocalObjectReference{
	// 				Name: awsCredentialsSecretName,
	// 			},
	// 			InstanceType: "m4.xlarge",
	// 			Placement: awsproviderv1.Placement{
	// 				Region:           region,
	// 				AvailabilityZone: defaultAvailabilityZone,
	// 			},
	// 			Subnet: awsproviderv1.AWSResourceReference{
	// 				ID: aws.String("subnet-0e56b13a64ff8a941"),
	// 			},
	// 			IAMInstanceProfile: &awsproviderv1.AWSResourceReference{
	// 				ID: aws.String("openshift_master_launch_instances"),
	// 			},
	// 			KeyName: aws.String(keyName),
	// 			UserDataSecret: &corev1.LocalObjectReference{
	// 				Name: userDataSecretName,
	// 			},
	// 			Tags: []awsproviderv1.TagSpecification{
	// 				{Name: "openshift-node-group-config", Value: "node-config-master"},
	// 				{Name: "host-type", Value: "master"},
	// 				{Name: "sub-host-type", Value: "default"},
	// 			},
	// 			SecurityGroups: []awsproviderv1.AWSResourceReference{{
	// 				Filters: []awsproviderv1.Filter{{
	// 					Name:   "tag:Name",
	// 					Values: []string{fmt.Sprintf("%s-%s-sg", clusterID, "role")},
	// 				}},
	// 			}},
	// 			PublicIP: aws.Bool(true),
	// 		},
	// 		userDataSecret:       stubUserDataSecret(),
	// 		awsCredentialsSecret: stubAwsCredentialsSecret(),
	// 		expectedError:        errors.New("failed to launch instance: error getting security groups IDs: error describing security groups: describeSecurityGroups error"),
	// 	},
	// 	{
	// 		testcase: "Failed Availability zones return invalid config machine error",
	// 		providerConfig: &awsproviderv1.AWSMachineProviderConfig{
	// 			AMI: awsproviderv1.AWSResourceReference{
	// 				ID: aws.String("ami-a9acbbd6"),
	// 			},
	// 			CredentialsSecret: &corev1.LocalObjectReference{
	// 				Name: awsCredentialsSecretName,
	// 			},
	// 			InstanceType: "m4.xlarge",
	// 			Placement: awsproviderv1.Placement{
	// 				Region:           region,
	// 				AvailabilityZone: defaultAvailabilityZone,
	// 			},
	// 			Subnet: awsproviderv1.AWSResourceReference{
	// 				Filters: []awsproviderv1.Filter{{
	// 					Name:   "tag:Name",
	// 					Values: []string{fmt.Sprintf("%s-private-%s", clusterID, "az")},
	// 				}},
	// 			},
	// 			IAMInstanceProfile: &awsproviderv1.AWSResourceReference{
	// 				ID: aws.String("openshift_master_launch_instances"),
	// 			},
	// 			KeyName: aws.String(keyName),
	// 			UserDataSecret: &corev1.LocalObjectReference{
	// 				Name: userDataSecretName,
	// 			},
	// 			Tags: []awsproviderv1.TagSpecification{
	// 				{Name: "openshift-node-group-config", Value: "node-config-master"},
	// 				{Name: "host-type", Value: "master"},
	// 				{Name: "sub-host-type", Value: "default"},
	// 			},
	// 			SecurityGroups: []awsproviderv1.AWSResourceReference{
	// 				{ID: aws.String("sg-00868b02fbe29de17")},
	// 				{ID: aws.String("sg-0a4658991dc5eb40a")},
	// 				{ID: aws.String("sg-009a70e28fa4ba84e")},
	// 				{ID: aws.String("sg-07323d56fb932c84c")},
	// 				{ID: aws.String("sg-08b1ffd32874d59a2")},
	// 			},
	// 			PublicIP: aws.Bool(true),
	// 		},
	// 		userDataSecret:       stubUserDataSecret(),
	// 		awsCredentialsSecret: stubAwsCredentialsSecret(),
	// 		expectedError:        errors.New("failed to launch instance: error getting subnet IDs: error describing availability zones: describeAvailabilityZones error"),
	// 	},
	// 	{
	// 		testcase: "Failed BlockDevices return invalid config machine error",
	// 		providerConfig: &awsproviderv1.AWSMachineProviderConfig{
	// 			AMI: awsproviderv1.AWSResourceReference{
	// 				ID: aws.String("ami-a9acbbd6"),
	// 			},
	// 			CredentialsSecret: &corev1.LocalObjectReference{
	// 				Name: awsCredentialsSecretName,
	// 			},
	// 			InstanceType: "m4.xlarge",
	// 			Placement: awsproviderv1.Placement{
	// 				Region:           region,
	// 				AvailabilityZone: defaultAvailabilityZone,
	// 			},
	// 			BlockDevices: []awsproviderv1.BlockDeviceMappingSpec{
	// 				{
	// 					EBS: &awsproviderv1.EBSBlockDeviceSpec{
	// 						VolumeType: pointer.StringPtr("type"),
	// 						VolumeSize: pointer.Int64Ptr(int64(1)),
	// 						Iops:       pointer.Int64Ptr(int64(1)),
	// 					},
	// 				},
	// 			},
	// 			Subnet: awsproviderv1.AWSResourceReference{
	// 				ID: aws.String("subnet-0e56b13a64ff8a941"),
	// 			},
	// 			IAMInstanceProfile: &awsproviderv1.AWSResourceReference{
	// 				ID: aws.String("openshift_master_launch_instances"),
	// 			},
	// 			KeyName: aws.String(keyName),
	// 			UserDataSecret: &corev1.LocalObjectReference{
	// 				Name: userDataSecretName,
	// 			},
	// 			Tags: []awsproviderv1.TagSpecification{
	// 				{Name: "openshift-node-group-config", Value: "node-config-master"},
	// 				{Name: "host-type", Value: "master"},
	// 				{Name: "sub-host-type", Value: "default"},
	// 			},
	// 			SecurityGroups: []awsproviderv1.AWSResourceReference{
	// 				{ID: aws.String("sg-00868b02fbe29de17")},
	// 				{ID: aws.String("sg-0a4658991dc5eb40a")},
	// 				{ID: aws.String("sg-009a70e28fa4ba84e")},
	// 				{ID: aws.String("sg-07323d56fb932c84c")},
	// 				{ID: aws.String("sg-08b1ffd32874d59a2")},
	// 			},
	// 			PublicIP: aws.Bool(true),
	// 		},
	// 		userDataSecret:       stubUserDataSecret(),
	// 		awsCredentialsSecret: stubAwsCredentialsSecret(),
	// 		expectedError:        errors.New("failed to launch instance: error getting blockDeviceMappings: error describing AMI: describeImages error"),
	// 	},
	// }
	// for _, tc := range testCases {
	// 	// create fake resources
	// 	t.Logf("testCase: %v", tc.testcase)

	// 	encodedProviderConfig, err := awsproviderv1.RawExtensionFromProviderSpec(tc.providerConfig)
	// 	if err != nil {
	// 		t.Fatalf("Unexpected error")
	// 	}
	// 	machine, err := stubMachine()
	// 	if err != nil {
	// 		t.Fatal(err)
	// 	}
	// 	machine.Spec.ProviderSpec = machinev1.ProviderSpec{Value: encodedProviderConfig}

	// 	fakeClient := fake.NewFakeClientWithScheme(scheme.Scheme, machine, tc.awsCredentialsSecret, tc.userDataSecret)

	// 	machineScope, err := newMachineScope(machineScopeParams{
	// 		client:  fakeClient,
	// 		machine: machine,
	// 		awsClientBuilder: func(client runtimeclient.Client, secretName, namespace, region string) (awsclient.Client, error) {
	// 			return mockAWSClient, nil
	// 		},
	// 	})
	// 	if err != nil {
	// 		t.Fatal(err)
	// 	}

	// 	reconciler := newProviderVM(machineScope)

	// 	// test create
	// 	err = reconciler.create()
	// 	if tc.expectedError != nil {
	// 		if err == nil {
	// 			t.Error("reconciler was expected to return error")
	// 		}
	// 		if err.Error() != tc.expectedError.Error() {
	// 			t.Errorf("Expected: %v, got %v", tc.expectedError, err)
	// 		}
	// 	} else {
	// 		if err != nil {
	// 			t.Errorf("reconciler was not expected to return error: %v", err)
	// 		}
	// 	}
	// }
}

func TestGetMachineInstances(t *testing.T) {
	// clusterID := "aws-actuator-cluster"
	// instanceID := "i-02fa4197109214b46"
	// imageID := "ami-a9acbbd6"

	// machine, err := stubMachine()
	// if err != nil {
	// 	t.Fatalf("unable to build stub machine: %v", err)
	// }

	// awsCredentialsSecret := stubAwsCredentialsSecret()
	// userDataSecret := stubUserDataSecret()

	// testCases := []struct {
	// 	testcase       string
	// 	providerStatus awsproviderv1.AWSMachineProviderStatus
	// 	awsClientFunc  func(*gomock.Controller) awsclient.Client
	// 	exists         bool
	// }{
	// 	{
	// 		testcase:       "empty-status-search-by-tag",
	// 		providerStatus: awsproviderv1.AWSMachineProviderStatus{},
	// 		awsClientFunc: func(ctrl *gomock.Controller) awsclient.Client {
	// 			mockAWSClient := mockaws.NewMockClient(ctrl)

	// 			request := &ec2.DescribeInstancesInput{
	// 				Filters: []*ec2.Filter{
	// 					{
	// 						Name:   awsTagFilter("Name"),
	// 						Values: aws.StringSlice([]string{machine.Name}),
	// 					},

	// 					clusterFilter(clusterID),
	// 				},
	// 			}

	// 			mockAWSClient.EXPECT().DescribeInstances(request).Return(
	// 				stubDescribeInstancesOutput(imageID, instanceID, ec2.InstanceStateNameRunning),
	// 				nil,
	// 			).Times(1)

	// 			return mockAWSClient
	// 		},
	// 		exists: true,
	// 	},
	// 	{
	// 		testcase: "has-status-search-by-id-running",
	// 		providerStatus: awsproviderv1.AWSMachineProviderStatus{
	// 			InstanceID: aws.String(instanceID),
	// 		},
	// 		awsClientFunc: func(ctrl *gomock.Controller) awsclient.Client {
	// 			mockAWSClient := mockaws.NewMockClient(ctrl)

	// 			request := &ec2.DescribeInstancesInput{
	// 				InstanceIds: aws.StringSlice([]string{instanceID}),
	// 			}

	// 			mockAWSClient.EXPECT().DescribeInstances(request).Return(
	// 				stubDescribeInstancesOutput(imageID, instanceID, ec2.InstanceStateNameRunning),
	// 				nil,
	// 			).Times(1)

	// 			return mockAWSClient
	// 		},
	// 		exists: true,
	// 	},
	// 	{
	// 		testcase: "has-status-search-by-id-terminated",
	// 		providerStatus: awsproviderv1.AWSMachineProviderStatus{
	// 			InstanceID: aws.String(instanceID),
	// 		},
	// 		awsClientFunc: func(ctrl *gomock.Controller) awsclient.Client {
	// 			mockAWSClient := mockaws.NewMockClient(ctrl)

	// 			first := mockAWSClient.EXPECT().DescribeInstances(&ec2.DescribeInstancesInput{
	// 				InstanceIds: aws.StringSlice([]string{instanceID}),
	// 			}).Return(
	// 				stubDescribeInstancesOutput(imageID, instanceID, ec2.InstanceStateNameTerminated),
	// 				nil,
	// 			).Times(1)

	// 			mockAWSClient.EXPECT().DescribeInstances(&ec2.DescribeInstancesInput{
	// 				Filters: []*ec2.Filter{
	// 					{
	// 						Name:   awsTagFilter("Name"),
	// 						Values: aws.StringSlice([]string{machine.Name}),
	// 					},

	// 					clusterFilter(clusterID),
	// 				},
	// 			}).Return(
	// 				stubDescribeInstancesOutput(imageID, instanceID, ec2.InstanceStateNameTerminated),
	// 				nil,
	// 			).Times(1).After(first)

	// 			return mockAWSClient
	// 		},
	// 	},
	// }

	// for _, tc := range testCases {
	// 	t.Run(tc.testcase, func(t *testing.T) {
	// 		ctrl := gomock.NewController(t)
	// 		defer ctrl.Finish()

	// 		awsStatusRaw, err := awsproviderv1.RawExtensionFromProviderStatus(&tc.providerStatus)
	// 		if err != nil {
	// 			t.Fatal(err)
	// 		}

	// 		machineCopy := machine.DeepCopy()
	// 		machineCopy.Status.ProviderStatus = awsStatusRaw

	// 		fakeClient := fake.NewFakeClientWithScheme(scheme.Scheme, machine, awsCredentialsSecret, userDataSecret)
	// 		mockAWSClient := tc.awsClientFunc(ctrl)

	// 		machineScope, err := newMachineScope(machineScopeParams{
	// 			client:  fakeClient,
	// 			machine: machineCopy,
	// 			awsClientBuilder: func(client runtimeclient.Client, secretName, namespace, region string) (awsclient.Client, error) {
	// 				return mockAWSClient, nil
	// 			},
	// 		})
	// 		if err != nil {
	// 			t.Fatal(err)
	// 		}

	// 		reconciler := newProviderVM(machineScope)

	// 		instances, err := reconciler.getMachineInstances()
	// 		if err != nil {
	// 			t.Errorf("Unexpected error from getMachineInstances: %v", err)
	// 		}
	// 		if tc.exists != (len(instances) > 0) {
	// 			t.Errorf("Expected instance exists: %t, got instances: %v", tc.exists, instances)
	// 		}
	// 	})
	// }
}
